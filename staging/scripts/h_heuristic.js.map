{"version":3,"sources":["h_heuristic.js"],"names":["H_Heuristic","history_score","m_TargetBuff","i","push","length","j","pos","depth","Math","pow","source","n","direction","s","mergePass","target","l","m","r","k","score","q","mergeAZ","mergeZA","h_heuristic"],"mappings":"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","file":"h_heuristic.js","sourcesContent":["/**\n * @fileOverview 历史启发模块 简言之在评估节点时，如果该节点引发剪枝，说明先评估该节点可能增加搜索效率，故增加其权重。越靠近根节点引发剪枝的，权重越高。历史启发不像杀手启发那样需要依赖棋类知识。\n */\n\"use strict\";\n/**\n * @module h_heuristic\n */\n\n/**\n * @see <a href=\"https://chessprogramming.wikispaces.com/History+Heuristic\">History Heuristic</a>\n */\nclass H_Heuristic {\n    constructor() {\n        /**\n         * @type {Array}\n         */\n        this.history_score = [];\n        /**\n         * @type {Array}\n         */\n        this.m_TargetBuff = [];\n    }\n    \n    /**\n     * 清除历史得分\n     */\n    clearHistoryScore() {\n        for (let i = 0; i < 15; i++) {\n            if (!this.history_score[i])\n                this.history_score.push(Array.from({length: 15}));\n            for (let j = 0; j < 15; j++) {\n                this.history_score[i][j] = 0;\n            }\n        }\n    }\n    \n    /**\n     * 增加历史得分记录\n     */\n    enterHistoryScore(pos, depth) {\n        this.history_score[pos[0]][pos[1]] += Math.pow(2, depth);\n    }\n    \n    /**\n     * 获取历史得分\n     * @param pos {Array}\n     */\n    getHistoryScore(pos) {\n        return this.history_score[pos[0]][pos[1]];\n    }\n    \n    // 以下几个函数排序用，采用的是归并排序 mergeSort 供外部调用，实际上棋盘上一共才225个位置，而且限定了走法范围，排序数组远小于这个规模，冒泡排序问题不大，看到有资料用这个，用来试试\n    static mergeAZ(source, target, l, m, r) {\n        let i = l,\n        j = m + 1,\n        k = l;\n        while ((i <= m) && (j <= r)) {\n            if (source[i].score <= source[j].score) {\n                target[k++] = source[i++];\n            } else {\n                target[k++] = source[j++];\n            }\n        }\n        if (i > m) {\n            for (let q = j; q <= r; q++) {\n                target[k++] = source[q];\n            }\n        } else {\n            for (let q = i; q <= m; q++) {\n                target[k++] = source[q];\n            }\n        }\n    }\n    \n    static mergeZA(source, target, l, m, r) {\n        let i = l,\n        j = m + 1,\n        k = l;\n        while ((i <= m) && (j <= r)) {\n            if (source[i].score >= source[j].score) {\n                target[k++] = source[i++];\n            } else {\n                target[k++] = source[j++];\n            }\n        }\n        if (i > m) {\n            for (let q = j; q <= r; q++) {\n                target[k++] = source[q];\n            }\n        } else {\n            for (let q = i; q <= m; q++) {\n                target[k++] = source[q];\n            }\n        }\n        \n    }\n    \n    static mergePass(source, target, s, n, direction) {\n        let i = 0;\n        while (i <= n - 2 * s) {\n            if (direction) {\n                this.mergeAZ(source, target, i, i + s - 1, i + 2 * s - 1);\n            } else {\n                this.mergeZA(source, target, i, i + s - 1, i + 2 * s - 1);\n            }\n            i = i + 2 * s;\n        }\n        if (i + s < n) {\n            if (direction) {\n                this.mergeAZ(source, target, i, i + s - 1, n - 1);\n            } else {\n                this.mergeZA(source, target, i, i + s - 1, n - 1);\n            }\n        } else {\n            for (let j = i; j <= n - 1; j++) {\n                target[j] = source[j];\n            }\n        }\n    }\n    \n    /**\n     * 供调用的排序API\n     * @param source\n     * @param n\n     * @param direction\n     */\n    mergeSort(source, n, direction) {\n        let s = 1;\n        while (s < n) {\n            H_Heuristic.mergePass(source, this.m_TargetBuff, s, n, direction);\n            s += s;\n            H_Heuristic.mergePass(this.m_TargetBuff, source, s, n, direction);\n            s += s;\n        }\n    }\n}\n/**\n * @type {H_Heuristic}\n */\nexport let h_heuristic = new H_Heuristic();"]}