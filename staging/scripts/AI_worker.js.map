{"version":3,"sources":["AI_worker.js"],"names":["max_dep","alpha","beta","step","steps_hist","virtual_b","best_move","score","addEventListener","e","data","clearHistoryScore","calculateInitHashKey","resolve","negaScout","then","postMessage","depth","to_try","a","b","t","bestIndex","exact","isGameOver","evaluate","lookUpHashTable","enterHashTable","getAvail","i","length","getHistoryScore","mergeSort","moveForward","hashMakeMove","hashUnMakeMove","moveBack","enterHistoryScore"],"mappings":"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","file":"AI_worker.js","sourcesContent":["/**\n * @fileOverview AI的主模块，依赖历史启发模块、置换表模块、走法生成模块和评估核心模块。接收主进程传递的数据后启动搜索函数，返回最佳走法和得分给主进程\n */\n/**\n * Web Worker\n * @module AI_worker\n * @see module: h_heuristic\n * @see module: t_table\n * @see module: move_generator\n * @see moduel: eval_function\n */\n\n\"use strict\";\nimport {h_heuristic} from './h_heuristic.js';\nimport {t_table} from './t_table.js';\nimport {m_gen} from './move_generator.js';\nimport {getScore} from './eval_function.js';\n\n// 和主进程的变量名相同，只是为了方便，是值相同的副本，但不共享状态\nlet max_dep, alpha, beta, step, steps_hist, virtual_b, best_move, score;\n\naddEventListener(\"message\", (e) => {\n    [max_dep, alpha, beta, step, virtual_b, steps_hist] = e.data;\n    h_heuristic.clearHistoryScore();\n    t_table.calculateInitHashKey(virtual_b);\n    Promise.resolve(negaScout(max_dep, alpha, beta))\n    .then(\n    function(e) {\n        score = e;\n        postMessage([score, best_move]);\n    }\n    )\n});\n\n/**\n * 搜索函数\n * @see <a href='https://en.wikipedia.org/wiki/Minimax'>Minimax</a>\n * @see <a href='https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning'>Alpha-beta pruning</a>\n * @see <a href='https://en.wikipedia.org/wiki/Principal_variation_search'>Principal_variation_search</a>\n * @param depth {number} 最大搜索深度，可以扩展由玩家选择难度\n * @param alpha {number} 下边界\n * @param beta {number} 上边界\n * @returns {number} 返回评分，最佳走法在函数中生成\n */\nfunction negaScout(depth, alpha, beta) {\n    let to_try, a, b, t, bestIndex, score, exact;\n    // 越靠近根节点，分数权重越高\n    // 如果游戏结束，停止这一分支的搜索，返回极值\n    if (getScore.isGameOver(step, virtual_b)) return getScore.evaluate(step, virtual_b) * (1 - (max_dep - depth) * .05);\n    score = t_table.lookUpHashTable(alpha, beta, depth);\n    if (score !== 404404) return score;\n    if (depth === 0) {\n        score = getScore.evaluate(step, virtual_b) * (1 - (max_dep - depth) * .05);\n        t_table.enterHashTable(0, score, depth);\n        return score;\n    }\n    to_try = m_gen.getAvail(virtual_b, steps_hist);\n    for (let i = 0; i < to_try.length; i++) {\n        to_try[i].score = h_heuristic.getHistoryScore(to_try[i]);\n    }\n    h_heuristic.mergeSort(to_try, to_try.length, 0);\n    bestIndex = -1;\n    a = alpha;\n    b = beta;\n    exact = 0;\n    for (let i = 0; i < to_try.length; i++) {\n        // 如果是根节点，发送进度数据给主进程\n        if (depth === max_dep) postMessage([i / to_try.length * 100, false]);\n        m_gen.moveForward(to_try[i], depth, step, virtual_b, max_dep, steps_hist);\n        t_table.hashMakeMove(to_try[i], virtual_b);\n        t = -negaScout(depth - 1, -b, -a);\n        if (t > a && t < beta && i > 0) {\n            a = -negaScout(depth - 1, -beta, -t);\n            exact = 1;\n            if (depth === max_dep) best_move = to_try[i];\n            bestIndex = i;\n        }\n        t_table.hashUnMakeMove(to_try[i], virtual_b);\n        m_gen.moveBack(to_try[i], step, virtual_b, steps_hist);\n        if (a < t) {\n            exact = 1;\n            a = t;\n            if (depth === max_dep) best_move = to_try[i];\n        }\n        if (a >= beta) {\n            t_table.enterHashTable(1, a, depth);\n            h_heuristic.enterHistoryScore(to_try[i], depth);\n            return a;\n        }\n        b = a + 1;\n    }\n    if (bestIndex !== -1) h_heuristic.enterHistoryScore(to_try[bestIndex], depth);\n    // 操作历史记录表\n    if (exact) {\n        t_table.enterHashTable(0, a, depth);\n    } else {\n        t_table.enterHashTable(-1, a, depth);\n    }\n    return a;\n}"]}